{"ast":null,"code":"var SDK = require('botkit-studio-sdk');\n\nmodule.exports = function (controller) {\n  var before_hooks = {};\n  var after_hooks = {};\n  var answer_hooks = {};\n  var thread_hooks = {}; // define a place for the studio specific features to live.\n\n  controller.studio = {};\n  /*\n   * ----------------------------------------------------------------\n   * Botkit Studio Script Services\n   * The features in this section grant access to Botkit Studio's\n   * script and trigger services\n   * ----------------------------------------------------------------\n   */\n\n  function genConfig(bot) {\n    var config = {};\n\n    if (bot.config && bot.config.studio_token) {\n      config.studio_token = bot.config.studio_token;\n    }\n\n    if (bot.config && bot.config.studio_command_uri) {\n      config.studio_command_uri = bot.config.studio_command_uri;\n    }\n\n    if (controller.config && controller.config.studio_token) {\n      config.studio_token = controller.config.studio_token;\n    }\n\n    if (controller.config && controller.config.studio_command_uri) {\n      config.studio_command_uri = controller.config.studio_command_uri;\n    }\n\n    return config;\n  }\n\n  controller.studio.evaluateTrigger = function (bot, text) {\n    var sdk = new SDK(genConfig(bot));\n    return sdk.evaluateTrigger(text);\n  }; // get Botkit Studio identity\n\n\n  controller.studio.identify = function (bot) {\n    var sdk = new SDK(genConfig(bot || {}));\n    return sdk.identify();\n  }; // get command list\n\n\n  controller.studio.getScripts = function (bot, tag) {\n    var sdk = new SDK(genConfig(bot || {}));\n    return sdk.getScripts(tag);\n  };\n  /*\n   * create a simple script\n   * with a single trigger and single reply\n   */\n\n\n  controller.studio.createScript = function (bot, trigger, text) {\n    var sdk = new SDK(genConfig(bot || {}));\n    return sdk.createScript(trigger, text);\n  }; // load a script from the pro service\n\n\n  controller.studio.getScriptById = function (bot, id) {\n    var sdk = new SDK(genConfig(bot));\n    return sdk.getScriptById(id);\n  }; // load a script from the pro service\n\n\n  controller.studio.getScript = function (bot, text) {\n    var sdk = new SDK(genConfig(bot));\n    return sdk.getScript(text);\n  }; // these are middleware functions\n\n\n  controller.studio.validate = function (command_name, key, func) {\n    if (!answer_hooks[command_name]) {\n      answer_hooks[command_name] = [];\n    }\n\n    if (key && !answer_hooks[command_name][key]) {\n      answer_hooks[command_name][key] = [];\n    }\n\n    answer_hooks[command_name][key].push(func);\n    return controller.studio;\n  };\n\n  controller.studio.beforeThread = function (command_name, thread_name, func) {\n    if (!thread_hooks[command_name]) {\n      thread_hooks[command_name] = [];\n    }\n\n    if (thread_name && !thread_hooks[command_name][thread_name]) {\n      thread_hooks[command_name][thread_name] = [];\n    }\n\n    thread_hooks[command_name][thread_name].push(func);\n    return controller.studio;\n  };\n\n  controller.studio.before = function (command_name, func) {\n    if (!before_hooks[command_name]) {\n      before_hooks[command_name] = [];\n    }\n\n    before_hooks[command_name].push(func);\n    return controller.studio;\n  };\n\n  controller.studio.after = function (command_name, func) {\n    if (!after_hooks[command_name]) {\n      after_hooks[command_name] = [];\n    }\n\n    after_hooks[command_name].push(func);\n    return controller.studio;\n  };\n\n  function runHooks(hooks, convo, cb) {\n    if (!hooks || !hooks.length) {\n      return cb(convo);\n    }\n\n    var func = hooks.shift();\n    func(convo, function () {\n      if (hooks.length) {\n        runHooks(hooks, convo, cb);\n      } else {\n        return cb(convo);\n      }\n    });\n  }\n  /*\n   * Fetch a script from Botkit Studio by name, then execute it.\n   * returns a promise that resolves when the conversation is loaded and active\n   */\n\n\n  controller.studio.run = function (bot, input_text, user, channel, original_message) {\n    return new Promise(function (resolve, reject) {\n      controller.studio.get(bot, input_text, user, channel, original_message).then(function (convo) {\n        convo.activate();\n        resolve(convo);\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n  /*\n   * Fetch a script from Botkit Studio by name, but do not execute it.\n   * returns a promise that resolves when the conversation is loaded\n   * but developer still needs to call convo.activate() to put it in motion\n   */\n\n\n  controller.studio.get = function (bot, input_text, user, channel, original_message) {\n    var context = {\n      text: input_text,\n      user: user,\n      channel: channel,\n      raw_message: original_message ? original_message.raw_message : null,\n      original_message: original_message || null\n    };\n    return new Promise(function (resolve, reject) {\n      controller.studio.getScript(bot, input_text).then(function (command) {\n        if (command !== {} && command.id) {\n          controller.trigger('command_triggered', [bot, context, command]); // make the script source information from Botkit Studio available to Botkit's convo object\n\n          context.script_name = command.command;\n          context.script_id = command._id;\n          controller.studio.compileScript(bot, context, command).then(function (convo) {\n            convo.on('end', function (convo) {\n              runHooks(after_hooks[command.command] ? after_hooks[command.command].slice() : [], convo, function (convo) {\n                controller.trigger('remote_command_end', [bot, context, command, convo]);\n              });\n            });\n            runHooks(before_hooks[command.command] ? before_hooks[command.command].slice() : [], convo, function (convo) {\n              resolve(convo);\n            });\n          }).catch(function (err) {\n            reject(err);\n          });\n        } else {\n          reject('Script not found');\n        }\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n  /*\n   * Fetch a script from Botkit Studio by id, but do not execute it.\n   * returns a promise that resolves when the conversation is loaded\n   * but developer still needs to call convo.activate() to put it in motion\n   */\n\n\n  controller.studio.getById = function (bot, id, user, channel, original_message) {\n    var context = {\n      id: id,\n      user: user,\n      channel: channel,\n      raw_message: original_message ? original_message.raw_message : null,\n      original_message: original_message || null\n    };\n    return new Promise(function (resolve, reject) {\n      controller.studio.getScriptById(bot, id).then(function (command) {\n        if (command !== {} && command.id) {\n          controller.trigger('command_triggered', [bot, context, command]); // make the script source information from Botkit Studio available to Botkit's convo object\n\n          context.script_name = command.command;\n          context.script_id = command._id;\n          controller.studio.compileScript(bot, context, command).then(function (convo) {\n            convo.on('end', function (convo) {\n              runHooks(after_hooks[command.command] ? after_hooks[command.command].slice() : [], convo, function (convo) {\n                controller.trigger('remote_command_end', [bot, context, command, convo]);\n              });\n            });\n            runHooks(before_hooks[command.command] ? before_hooks[command.command].slice() : [], convo, function (convo) {\n              resolve(convo);\n            });\n          }).catch(function (err) {\n            reject(err);\n          });\n        } else {\n          reject('Script not found');\n        }\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  controller.studio.runTrigger = function (bot, input_text, user, channel, original_message) {\n    var context = {\n      text: input_text,\n      user: user,\n      channel: channel,\n      raw_message: original_message ? original_message.raw_message : null,\n      original_message: original_message || null\n    };\n    return new Promise(function (resolve, reject) {\n      controller.studio.evaluateTrigger(bot, input_text).then(function (command) {\n        if (command !== {} && command.id) {\n          controller.trigger('command_triggered', [bot, context, command]); // make the script source information from Botkit Studio available to Botkit's convo object\n\n          context.script_name = command.command;\n          context.script_id = command._id;\n          controller.studio.compileScript(bot, context, command).then(function (convo) {\n            convo.on('end', function (convo) {\n              runHooks(after_hooks[command.command] ? after_hooks[command.command].slice() : [], convo, function (convo) {\n                controller.trigger('remote_command_end', [bot, context, command, convo]);\n              });\n            });\n            runHooks(before_hooks[command.command] ? before_hooks[command.command].slice() : [], convo, function (convo) {\n              convo.activate();\n              resolve(convo);\n            });\n          }).catch(function (err) {\n            reject(err);\n          });\n        } else {\n          /*\n           * return with no conversation\n           * allow developer to run a default script\n           */\n          resolve(null);\n        }\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  controller.studio.testTrigger = function (bot, input_text) {\n    return new Promise(function (resolve, reject) {\n      controller.studio.evaluateTrigger(bot, input_text).then(function (command) {\n        if (command !== {} && command.id) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  controller.studio.compileScript = function (bot, message, command) {\n    function makeHandler(options, field) {\n      var pattern = '';\n\n      if (options.type == 'utterance') {\n        pattern = controller.utterances[options.pattern];\n      } else if (options.type == 'string') {\n        var p = options.pattern;\n        p = p.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n        pattern = '^' + p + '$';\n      } else if (options.type == 'regex') {\n        pattern = options.pattern;\n      }\n\n      return {\n        pattern: pattern,\n        default: options.default,\n        callback: function callback(response, convo) {\n          var hooks = [];\n\n          if (field.key && answer_hooks[command.command] && answer_hooks[command.command][field.key]) {\n            hooks = answer_hooks[command.command][field.key].slice();\n          }\n\n          if (options.action != 'wait' && field.multiple) {\n            convo.responses[field.key].pop();\n          }\n\n          runHooks(hooks, convo, function (convo) {\n            convo.handleAction(options);\n          });\n        }\n      };\n    }\n\n    return new Promise(function (resolve, reject) {\n      bot.createConversation(message, function (err, convo) {\n        if (err) {\n          return reject(err);\n        } // 15 minute default timeout\n\n\n        convo.setTimeout(controller.config.default_timeout || 15 * 60 * 1000); // process any variables values and entities that came pre-defined as part of the script\n\n        if (command.variables && command.variables.length) {\n          for (var v = 0; v < command.variables.length; v++) {\n            if (command.variables[v].value) {\n              /*\n               * set the key/value as a mustache variable\n               * accessible as {{vars.name}} in the templates\n               */\n              convo.setVar(command.variables[v].name, command.variables[v].value);\n              /*\n               * also add this as an \"answer\" to a question\n               * thus making it available at {{responses.name}} and\n               * convo.extractResponse(name);\n               */\n\n              convo.responses[command.variables[v].name] = {\n                question: command.variables[v].name,\n                text: command.variables[v].value\n              };\n            }\n          }\n        }\n\n        for (var t = 0; t < command.script.length; t++) {\n          var topic = command.script[t].topic;\n\n          for (var m = 0; m < command.script[t].script.length; m++) {\n            if (command.script[t].script[m].conditional) {\n              convo.addConditional({\n                conditional: command.script[t].script[m].conditional\n              }, topic);\n            } else {\n              var message = {};\n\n              if (command.script[t].script[m].text) {\n                message.text = command.script[t].script[m].text;\n              } // handle platform specific fields\n\n\n              if (bot.type == 'ciscospark' || bot.type == 'webex') {\n                if (command.script[t].script[m].platforms && command.script[t].script[m].platforms.ciscospark) {\n                  // attach files.\n                  if (command.script[t].script[m].platforms.ciscospark.files) {\n                    message.files = [];\n\n                    for (var f = 0; f < command.script[t].script[m].platforms.ciscospark.files.length; f++) {\n                      message.files.push(command.script[t].script[m].platforms.ciscospark.files[f].url);\n                    }\n                  }\n                }\n              }\n\n              if (bot.type == 'web' || bot.type == 'socket') {\n                if (command.script[t].script[m].platforms && command.script[t].script[m].platforms.web) {\n                  // attach files.\n                  if (command.script[t].script[m].platforms.web.files) {\n                    message.files = [];\n\n                    for (var f = 0; f < command.script[t].script[m].platforms.web.files.length; f++) {\n                      // determine if this is an image or any other type of file.\n                      command.script[t].script[m].platforms.web.files[f].image = command.script[t].script[m].platforms.web.files[f].url.match(/\\.(jpeg|jpg|gif|png)$/i) != null;\n                      message.files.push(command.script[t].script[m].platforms.web.files[f]);\n                    }\n                  }\n                }\n              }\n\n              if (bot.type == 'teams') {\n                if (command.script[t].script[m].platforms && command.script[t].script[m].platforms.teams) {\n                  // create attachments in the Botkit message\n                  if (command.script[t].script[m].platforms && command.script[t].script[m].platforms.teams.attachmentLayout) {\n                    message.attachmentLayout = command.script[t].script[m].platforms && command.script[t].script[m].platforms.teams.attachmentLayout;\n                  }\n\n                  if (command.script[t].script[m].platforms.teams.attachments) {\n                    message.attachments = [];\n\n                    for (var a = 0; a < command.script[t].script[m].platforms.teams.attachments.length; a++) {\n                      var data = command.script[t].script[m].platforms.teams.attachments[a];\n                      var attachment = {};\n\n                      if (data.type == 'o365') {\n                        attachment.contentType = 'application/vnd.microsoft.card.O365Connector'; // + data.type,\n\n                        data['@type'] = 'MessageCard';\n                        data['@context'] = 'http://schema.org/extensions';\n                        delete data.type;\n                        attachment.content = data;\n                      } else if (data.type != 'file') {\n                        attachment = bot.createAttachment(data.type, data);\n                      } else {\n                        attachment.contentType = data.contentType;\n                        attachment.contentUrl = data.contentUrl;\n                        attachment.name = data.name;\n                      }\n\n                      message.attachments.push(attachment);\n                    }\n                  }\n                }\n              } // handle Slack attachments\n\n\n              if (command.script[t].script[m].attachments) {\n                message.attachments = command.script[t].script[m].attachments; // enable mrkdwn formatting in all fields of the attachment\n\n                for (var a = 0; a < message.attachments.length; a++) {\n                  message.attachments[a].mrkdwn_in = ['text', 'pretext', 'fields'];\n                  message.attachments[a].mrkdwn = true;\n                }\n              } // handle Facebook attachments\n\n\n              if (command.script[t].script[m].fb_attachment) {\n                var attachment = command.script[t].script[m].fb_attachment;\n\n                if (attachment.template_type) {\n                  if (attachment.template_type == 'button') {\n                    attachment.text = message.text;\n                  }\n\n                  message.attachment = {\n                    type: 'template',\n                    payload: attachment\n                  };\n                } else if (attachment.type) {\n                  message.attachment = attachment;\n                } // blank text, not allowed with attachment\n\n\n                message.text = null; // remove blank button array if specified\n\n                if (message.attachment.payload.elements) {\n                  for (var e = 0; e < message.attachment.payload.elements.length; e++) {\n                    if (!message.attachment.payload.elements[e].buttons || !message.attachment.payload.elements[e].buttons.length) {\n                      delete message.attachment.payload.elements[e].buttons;\n                    }\n                  }\n                }\n              } // handle Facebook quick replies\n\n\n              if (command.script[t].script[m].quick_replies) {\n                var options = command.script[t].script[m].quick_replies;\n\n                if (!message.quick_replies) {\n                  message.quick_replies = [];\n                }\n\n                for (var o = 0; o < options.length; o++) {\n                  message.quick_replies.push(options[o]);\n                }\n              } // handle Facebook quick replies that are embedded in question options\n\n\n              if (command.script[t].script[m].collect) {\n                var options = command.script[t].script[m].collect.options || [];\n\n                if (options.length > 0) {\n                  for (var o = 0; o < options.length; o++) {\n                    if (options[o].fb_quick_reply) {\n                      if (!message.quick_replies) {\n                        message.quick_replies = [];\n                      }\n\n                      message.quick_replies.push({\n                        title: options[o].pattern,\n                        payload: options[o].fb_quick_reply_payload,\n                        image_url: options[o].fb_quick_reply_image_url,\n                        content_type: options[o].fb_quick_reply_content_type\n                      });\n                    }\n                  }\n                }\n              }\n\n              if (command.script[t].script[m].action) {\n                message.action = command.script[t].script[m].action;\n\n                if (command.script[t].script[m].execute) {\n                  message.execute = command.script[t].script[m].execute;\n                }\n              } // handle meta data\n\n\n              if (command.script[t].script[m].meta) {\n                for (var a = 0; a < command.script[t].script[m].meta.length; a++) {\n                  message[command.script[t].script[m].meta[a].key] = command.script[t].script[m].meta[a].value;\n                }\n              }\n\n              if (command.script[t].script[m].collect) {\n                // this is a question message\n                var capture_options = {};\n                var handlers = [];\n                var options = command.script[t].script[m].collect.options || [];\n\n                if (command.script[t].script[m].collect.key) {\n                  capture_options.key = command.script[t].script[m].collect.key;\n                }\n\n                if (command.script[t].script[m].collect.multiple) {\n                  capture_options.multiple = true;\n                }\n\n                var default_found = false;\n\n                for (var o = 0; o < options.length; o++) {\n                  var handler = makeHandler(options[o], capture_options);\n                  handlers.push(handler);\n\n                  if (options[o].default) {\n                    default_found = true;\n                  }\n                } // make sure there is a default\n\n\n                if (!default_found) {\n                  handlers.push({\n                    default: true,\n                    callback: function callback(r, c) {\n                      runHooks(answer_hooks[command.command] ? answer_hooks[command.command].slice() : [], convo, function () {\n                        c.next();\n                      });\n                    }\n                  });\n                }\n\n                convo.addQuestion(message, handlers, capture_options, topic);\n              } else {\n                // this is a simple message\n                convo.addMessage(message, topic);\n              }\n            } // if !conditional\n\n          } // add thread hooks if they have been defined.\n\n\n          if (thread_hooks[command.command] && thread_hooks[command.command][topic]) {\n            for (var h = 0; h < thread_hooks[command.command][topic].length; h++) {\n              convo.beforeThread(topic, thread_hooks[command.command][topic][h]);\n            }\n          }\n        }\n\n        resolve(convo);\n      });\n    });\n  };\n};","map":null,"metadata":{},"sourceType":"module"}