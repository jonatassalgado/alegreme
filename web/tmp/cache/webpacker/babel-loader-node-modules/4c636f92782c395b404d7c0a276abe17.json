{"ast":null,"code":"/**\n * Module Dependencies\n */\nvar noop = function noop() {};\n\nvar co = require('co');\n/**\n * Export `wrap-fn`\n */\n\n\nmodule.exports = wrap;\n/**\n * Wrap a function to support\n * sync, async, and gen functions.\n *\n * @param {Function} fn\n * @param {Function} done\n * @return {Function}\n * @api public\n */\n\nfunction wrap(fn, done) {\n  done = once(done || noop);\n  return function () {\n    // prevents arguments leakage\n    // see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n\n    while (i--) {\n      args[i] = arguments[i];\n    }\n\n    var ctx = this; // done\n\n    if (!fn) {\n      return done.apply(ctx, [null].concat(args));\n    } // async\n\n\n    if (fn.length > args.length) {\n      // NOTE: this only handles uncaught synchronous errors\n      try {\n        return fn.apply(ctx, args.concat(done));\n      } catch (e) {\n        return done(e);\n      }\n    } // generator\n\n\n    if (generator(fn)) {\n      return co(fn).apply(ctx, args.concat(done));\n    } // sync\n\n\n    return sync(fn, done).apply(ctx, args);\n  };\n}\n/**\n * Wrap a synchronous function execution.\n *\n * @param {Function} fn\n * @param {Function} done\n * @return {Function}\n * @api private\n */\n\n\nfunction sync(fn, done) {\n  return function () {\n    var ret;\n\n    try {\n      ret = fn.apply(this, arguments);\n    } catch (err) {\n      return done(err);\n    }\n\n    if (promise(ret)) {\n      ret.then(function (value) {\n        done(null, value);\n      }, done);\n    } else {\n      ret instanceof Error ? done(ret) : done(null, ret);\n    }\n  };\n}\n/**\n * Is `value` a generator?\n *\n * @param {Mixed} value\n * @return {Boolean}\n * @api private\n */\n\n\nfunction generator(value) {\n  return value && value.constructor && 'GeneratorFunction' == value.constructor.name;\n}\n/**\n * Is `value` a promise?\n *\n * @param {Mixed} value\n * @return {Boolean}\n * @api private\n */\n\n\nfunction promise(value) {\n  return value && 'function' == typeof value.then;\n}\n/**\n * Once\n */\n\n\nfunction once(fn) {\n  return function () {\n    var ret = fn.apply(this, arguments);\n    fn = noop;\n    return ret;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}