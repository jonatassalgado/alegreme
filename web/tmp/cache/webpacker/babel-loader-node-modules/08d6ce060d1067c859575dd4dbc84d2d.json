{"ast":null,"code":"/**\n * Module Dependencies\n */\nvar slice = [].slice;\n\nvar wrap = require('wrap-fn');\n/**\n * Expose `Ware`.\n */\n\n\nmodule.exports = Ware;\n/**\n * Throw an error.\n *\n * @param {Error} error\n */\n\nfunction fail(err) {\n  throw err;\n}\n/**\n * Initialize a new `Ware` manager, with optional `fns`.\n *\n * @param {Function or Array or Ware} fn (optional)\n */\n\n\nfunction Ware(fn) {\n  if (!(this instanceof Ware)) return new Ware(fn);\n  this.fns = [];\n  if (fn) this.use(fn);\n}\n/**\n * Use a middleware `fn`.\n *\n * @param {Function or Array or Ware} fn\n * @return {Ware}\n */\n\n\nWare.prototype.use = function (fn) {\n  if (fn instanceof Ware) {\n    return this.use(fn.fns);\n  }\n\n  if (fn instanceof Array) {\n    for (var i = 0, f; f = fn[i++];) {\n      this.use(f);\n    }\n\n    return this;\n  }\n\n  this.fns.push(fn);\n  return this;\n};\n/**\n * Run through the middleware with the given `args` and optional `callback`.\n *\n * @param {Mixed} args...\n * @param {Function} callback (optional)\n * @return {Ware}\n */\n\n\nWare.prototype.run = function () {\n  var fns = this.fns;\n  var ctx = this;\n  var i = 0;\n  var last = arguments[arguments.length - 1];\n  var done = 'function' == typeof last && last;\n  var args = done ? slice.call(arguments, 0, arguments.length - 1) : slice.call(arguments); // next step\n\n  function next(err) {\n    if (err) return (done || fail)(err);\n    var fn = fns[i++];\n    var arr = slice.call(args);\n\n    if (!fn) {\n      return done && done.apply(null, [null].concat(args));\n    }\n\n    wrap(fn, next).apply(ctx, arr);\n  }\n\n  next();\n  return this;\n};","map":null,"metadata":{},"sourceType":"module"}