{"ast":null,"code":"function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport MDCTopAppBarAdapter from '../adapter';\nimport MDCTopAppBarBaseFoundation from '../foundation';\nimport { numbers } from '../constants';\nvar INITIAL_VALUE = 0;\n/**\n * @extends {MDCTopAppBarBaseFoundation<!MDCTopAppBarFoundation>}\n * @final\n */\n\nvar MDCTopAppBarFoundation =\n/*#__PURE__*/\nfunction (_MDCTopAppBarBaseFoun) {\n  _inherits(MDCTopAppBarFoundation, _MDCTopAppBarBaseFoun);\n\n  /**\n   * @param {!MDCTopAppBarAdapter} adapter\n   */\n  function MDCTopAppBarFoundation(adapter) {\n    var _this;\n\n    _classCallCheck(this, MDCTopAppBarFoundation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTopAppBarFoundation).call(this, adapter));\n    /**\n     * Used for diffs of current scroll position vs previous scroll position\n     * @private {number}\n     */\n\n    _this.lastScrollPosition_ = _this.adapter_.getViewportScrollY();\n    /**\n     * Used to verify when the top app bar is completely showing or completely hidden\n     * @private {number}\n     */\n\n    _this.topAppBarHeight_ = _this.adapter_.getTopAppBarHeight();\n    /**\n     * wasDocked_ is used to indicate if the top app bar was docked in the previous\n     * scroll handler iteration.\n     * @private {boolean}\n     */\n\n    _this.wasDocked_ = true;\n    /**\n     * isDockedShowing_ is used to indicate if the top app bar is docked in the fully\n     * shown position.\n     * @private {boolean}\n     */\n\n    _this.isDockedShowing_ = true;\n    /**\n     * Variable for current scroll position of the top app bar\n     * @private {number}\n     */\n\n    _this.currentAppBarOffsetTop_ = 0;\n    /**\n     * Used to prevent the top app bar from being scrolled out of view during resize events\n     * @private {boolean} */\n\n    _this.isCurrentlyBeingResized_ = false;\n    /**\n     * The timeout that's used to throttle the resize events\n     * @private {number}\n     */\n\n    _this.resizeThrottleId_ = INITIAL_VALUE;\n    /**\n     * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize\n     * @private {number}\n     */\n\n    _this.resizeDebounceId_ = INITIAL_VALUE;\n\n    _this.scrollHandler_ = function () {\n      return _this.topAppBarScrollHandler_();\n    };\n\n    _this.resizeHandler_ = function () {\n      return _this.topAppBarResizeHandler_();\n    };\n\n    return _this;\n  }\n\n  _createClass(MDCTopAppBarFoundation, [{\n    key: \"init\",\n    value: function init() {\n      _get(_getPrototypeOf(MDCTopAppBarFoundation.prototype), \"init\", this).call(this);\n\n      this.adapter_.registerScrollHandler(this.scrollHandler_);\n      this.adapter_.registerResizeHandler(this.resizeHandler_);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(MDCTopAppBarFoundation.prototype), \"destroy\", this).call(this);\n\n      this.adapter_.deregisterScrollHandler(this.scrollHandler_);\n      this.adapter_.deregisterResizeHandler(this.resizeHandler_);\n      this.adapter_.setStyle('top', '');\n    }\n    /**\n     * Function to determine if the DOM needs to update.\n     * @return {boolean}\n     * @private\n     */\n\n  }, {\n    key: \"checkForUpdate_\",\n    value: function checkForUpdate_() {\n      var offscreenBoundaryTop = -this.topAppBarHeight_;\n      var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;\n      var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;\n      var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen; // If it's partially showing, it can't be docked.\n\n      if (partiallyShowing) {\n        this.wasDocked_ = false;\n      } else {\n        // Not previously docked and not partially showing, it's now docked.\n        if (!this.wasDocked_) {\n          this.wasDocked_ = true;\n          return true;\n        } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {\n          this.isDockedShowing_ = hasAnyPixelsOnscreen;\n          return true;\n        }\n      }\n\n      return partiallyShowing;\n    }\n    /**\n     * Function to move the top app bar if needed.\n     * @private\n     */\n\n  }, {\n    key: \"moveTopAppBar_\",\n    value: function moveTopAppBar_() {\n      if (this.checkForUpdate_()) {\n        // Once the top app bar is fully hidden we use the max potential top app bar height as our offset\n        // so the top app bar doesn't show if the window resizes and the new height > the old height.\n        var offset = this.currentAppBarOffsetTop_;\n\n        if (Math.abs(offset) >= this.topAppBarHeight_) {\n          offset = -numbers.MAX_TOP_APP_BAR_HEIGHT;\n        }\n\n        this.adapter_.setStyle('top', offset + 'px');\n      }\n    }\n    /**\n     * Scroll handler for the default scroll behavior of the top app bar.\n     * @private\n     */\n\n  }, {\n    key: \"topAppBarScrollHandler_\",\n    value: function topAppBarScrollHandler_() {\n      var currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);\n      var diff = currentScrollPosition - this.lastScrollPosition_;\n      this.lastScrollPosition_ = currentScrollPosition; // If the window is being resized the lastScrollPosition_ needs to be updated but the\n      // current scroll of the top app bar should stay in the same position.\n\n      if (!this.isCurrentlyBeingResized_) {\n        this.currentAppBarOffsetTop_ -= diff;\n\n        if (this.currentAppBarOffsetTop_ > 0) {\n          this.currentAppBarOffsetTop_ = 0;\n        } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {\n          this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;\n        }\n\n        this.moveTopAppBar_();\n      }\n    }\n    /**\n     * Top app bar resize handler that throttle/debounce functions that execute updates.\n     * @private\n     */\n\n  }, {\n    key: \"topAppBarResizeHandler_\",\n    value: function topAppBarResizeHandler_() {\n      var _this2 = this;\n\n      // Throttle resize events 10 p/s\n      if (!this.resizeThrottleId_) {\n        this.resizeThrottleId_ = setTimeout(function () {\n          _this2.resizeThrottleId_ = INITIAL_VALUE;\n\n          _this2.throttledResizeHandler_();\n        }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);\n      }\n\n      this.isCurrentlyBeingResized_ = true;\n\n      if (this.resizeDebounceId_) {\n        clearTimeout(this.resizeDebounceId_);\n      }\n\n      this.resizeDebounceId_ = setTimeout(function () {\n        _this2.topAppBarScrollHandler_();\n\n        _this2.isCurrentlyBeingResized_ = false;\n        _this2.resizeDebounceId_ = INITIAL_VALUE;\n      }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);\n    }\n    /**\n     * Throttled function that updates the top app bar scrolled values if the\n     * top app bar height changes.\n     * @private\n     */\n\n  }, {\n    key: \"throttledResizeHandler_\",\n    value: function throttledResizeHandler_() {\n      var currentHeight = this.adapter_.getTopAppBarHeight();\n\n      if (this.topAppBarHeight_ !== currentHeight) {\n        this.wasDocked_ = false; // Since the top app bar has a different height depending on the screen width, this\n        // will ensure that the top app bar remains in the correct location if\n        // completely hidden and a resize makes the top app bar a different height.\n\n        this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;\n        this.topAppBarHeight_ = currentHeight;\n      }\n\n      this.topAppBarScrollHandler_();\n    }\n  }]);\n\n  return MDCTopAppBarFoundation;\n}(MDCTopAppBarBaseFoundation);\n\nexport default MDCTopAppBarFoundation;","map":null,"metadata":{},"sourceType":"module"}