{"ast":null,"code":"/**\n * slice() reference.\n */\nvar slice = Array.prototype.slice;\n/**\n * Expose `co`.\n */\n\nmodule.exports = co;\n/**\n * Wrap the given generator `fn` and\n * return a thunk.\n *\n * @param {Function} fn\n * @return {Function}\n * @api public\n */\n\nfunction co(fn) {\n  var isGenFun = isGeneratorFunction(fn);\n  return function (done) {\n    var ctx = this; // in toThunk() below we invoke co()\n    // with a generator, so optimize for\n    // this case\n\n    var gen = fn; // we only need to parse the arguments\n    // if gen is a generator function.\n\n    if (isGenFun) {\n      var args = slice.call(arguments),\n          len = args.length;\n      var hasCallback = len && 'function' == typeof args[len - 1];\n      done = hasCallback ? args.pop() : error;\n      gen = fn.apply(this, args);\n    } else {\n      done = done || error;\n    }\n\n    next(); // #92\n    // wrap the callback in a setImmediate\n    // so that any of its errors aren't caught by `co`\n\n    function exit(err, res) {\n      setImmediate(function () {\n        done.call(ctx, err, res);\n      });\n    }\n\n    function next(err, res) {\n      var ret; // multiple args\n\n      if (arguments.length > 2) res = slice.call(arguments, 1); // error\n\n      if (err) {\n        try {\n          ret = gen.throw(err);\n        } catch (e) {\n          return exit(e);\n        }\n      } // ok\n\n\n      if (!err) {\n        try {\n          ret = gen.next(res);\n        } catch (e) {\n          return exit(e);\n        }\n      } // done\n\n\n      if (ret.done) return exit(null, ret.value); // normalize\n\n      ret.value = toThunk(ret.value, ctx); // run\n\n      if ('function' == typeof ret.value) {\n        var called = false;\n\n        try {\n          ret.value.call(ctx, function () {\n            if (called) return;\n            called = true;\n            next.apply(ctx, arguments);\n          });\n        } catch (e) {\n          setImmediate(function () {\n            if (called) return;\n            called = true;\n            next(e);\n          });\n        }\n\n        return;\n      } // invalid\n\n\n      next(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following was passed: \"' + String(ret.value) + '\"'));\n    }\n  };\n}\n/**\n * Convert `obj` into a normalized thunk.\n *\n * @param {Mixed} obj\n * @param {Mixed} ctx\n * @return {Function}\n * @api private\n */\n\n\nfunction toThunk(obj, ctx) {\n  if (isGeneratorFunction(obj)) {\n    return co(obj.call(ctx));\n  }\n\n  if (isGenerator(obj)) {\n    return co(obj);\n  }\n\n  if (isPromise(obj)) {\n    return promiseToThunk(obj);\n  }\n\n  if ('function' == typeof obj) {\n    return obj;\n  }\n\n  if (isObject(obj) || Array.isArray(obj)) {\n    return objectToThunk.call(ctx, obj);\n  }\n\n  return obj;\n}\n/**\n * Convert an object of yieldables to a thunk.\n *\n * @param {Object} obj\n * @return {Function}\n * @api private\n */\n\n\nfunction objectToThunk(obj) {\n  var ctx = this;\n  var isArray = Array.isArray(obj);\n  return function (done) {\n    var keys = Object.keys(obj);\n    var pending = keys.length;\n    var results = isArray ? new Array(pending) // predefine the array length\n    : new obj.constructor();\n    var finished;\n\n    if (!pending) {\n      setImmediate(function () {\n        done(null, results);\n      });\n      return;\n    } // prepopulate object keys to preserve key ordering\n\n\n    if (!isArray) {\n      for (var i = 0; i < pending; i++) {\n        results[keys[i]] = undefined;\n      }\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      run(obj[keys[i]], keys[i]);\n    }\n\n    function run(fn, key) {\n      if (finished) return;\n\n      try {\n        fn = toThunk(fn, ctx);\n\n        if ('function' != typeof fn) {\n          results[key] = fn;\n          return --pending || done(null, results);\n        }\n\n        fn.call(ctx, function (err, res) {\n          if (finished) return;\n\n          if (err) {\n            finished = true;\n            return done(err);\n          }\n\n          results[key] = res;\n          --pending || done(null, results);\n        });\n      } catch (err) {\n        finished = true;\n        done(err);\n      }\n    }\n  };\n}\n/**\n * Convert `promise` to a thunk.\n *\n * @param {Object} promise\n * @return {Function}\n * @api private\n */\n\n\nfunction promiseToThunk(promise) {\n  return function (fn) {\n    promise.then(function (res) {\n      fn(null, res);\n    }, fn);\n  };\n}\n/**\n * Check if `obj` is a promise.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\n\nfunction isPromise(obj) {\n  return obj && 'function' == typeof obj.then;\n}\n/**\n * Check if `obj` is a generator.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\n\nfunction isGenerator(obj) {\n  return obj && 'function' == typeof obj.next && 'function' == typeof obj.throw;\n}\n/**\n * Check if `obj` is a generator function.\n *\n * @param {Mixed} obj\n * @return {Boolean}\n * @api private\n */\n\n\nfunction isGeneratorFunction(obj) {\n  return obj && obj.constructor && 'GeneratorFunction' == obj.constructor.name;\n}\n/**\n * Check for plain object.\n *\n * @param {Mixed} val\n * @return {Boolean}\n * @api private\n */\n\n\nfunction isObject(val) {\n  return val && Object == val.constructor;\n}\n/**\n * Throw `err` in a new stack.\n *\n * This is used when co() is invoked\n * without supplying a callback, which\n * should only be for demonstrational\n * purposes.\n *\n * @param {Error} err\n * @api private\n */\n\n\nfunction error(err) {\n  if (!err) return;\n  setImmediate(function () {\n    throw err;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}