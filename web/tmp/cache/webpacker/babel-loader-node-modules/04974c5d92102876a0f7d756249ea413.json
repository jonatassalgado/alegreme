{"ast":null,"code":"var Botkit = require(__dirname + '/CoreBot.js');\n\nvar WebSocket = require('ws');\n\nfunction WebBot(configuration) {\n  var controller = Botkit(configuration || {});\n\n  if (controller.config.typingDelayFactor === undefined) {\n    controller.config.typingDelayFactor = 1;\n  }\n\n  controller.excludeFromConversations(['hello', 'welcome_back', 'reconnect']);\n\n  controller.openSocketServer = function (server) {\n    // create the socket server along side the existing webserver.\n    var wss = new WebSocket.Server({\n      server: server\n    }); // Expose the web socket server object to the controller so it can be used later.\n\n    controller.wss = wss;\n\n    function heartbeat() {\n      this.isAlive = true;\n    }\n\n    wss.on('connection', function connection(ws) {\n      ws.isAlive = true;\n      ws.on('pong', heartbeat); // search through all the convos, if a bot matches, update its ws\n\n      var bot = controller.spawn();\n      bot.ws = ws;\n      bot.connected = true;\n      ws.on('message', function incoming(message) {\n        try {\n          var message = JSON.parse(message);\n          controller.ingest(bot, message, ws);\n        } catch (e) {\n          var alert = [\"Error parsing incoming message from websocket.\", \"Message must be JSON, and should be in the format documented here:\", \"https://botkit.ai/docs/readme-web.html#message-objects\"];\n          console.error(alert.join('\\n'));\n          console.error(e);\n        }\n      });\n      ws.on('error', function (err) {\n        return console.error('Websocket Error: ', err);\n      });\n      ws.on('close', function () {\n        bot.connected = false;\n      });\n    });\n    setInterval(function ping() {\n      wss.clients.forEach(function each(ws) {\n        if (ws.isAlive === false) {\n          return ws.terminate();\n        } //  if (ws.isAlive === false) return ws.terminate()\n\n\n        ws.isAlive = false;\n        ws.ping('', false, true);\n      });\n    }, 30000);\n  };\n\n  controller.middleware.ingest.use(function (bot, message, reply_channel, next) {\n    /*\n     * this could be a message from the WebSocket\n     * or it might be coming from a webhook.\n     * configure the bot appropriately so the reply goes to the right place!\n     */\n    if (!bot.ws) {\n      bot.http_response = reply_channel;\n    }\n    /*\n     * look for an existing conversation for this user/channel combo\n     * why not just pass in message? because we only care if there is a conversation  ongoing\n     * and we might be dealing with \"silent\" message that would not otherwise match a conversation\n     */\n\n\n    bot.findConversation({\n      user: message.user,\n      channel: message.channel\n    }, function (convo) {\n      if (convo) {\n        if (bot.ws) {\n          // replace the websocket connection\n          convo.task.bot.ws = bot.ws;\n          convo.task.bot.connected = true;\n\n          if (message.type == 'hello' || message.type == 'welcome_back') {\n            message.type = 'reconnect';\n          }\n        } else {\n          /*\n           * replace the reply channel in the active conversation\n           * this is the one that gets used to send the actual reply\n           */\n          convo.task.bot.http_response = bot.http_response;\n        }\n      }\n\n      next();\n    });\n  });\n  controller.middleware.categorize.use(function (bot, message, next) {\n    if (message.type == 'message') {\n      message.type = 'message_received';\n    }\n\n    next();\n  }); // simple message clone because its already in the right format!\n\n  controller.middleware.format.use(function (bot, message, platform_message, next) {\n    for (var key in message) {\n      platform_message[key] = message[key];\n    }\n\n    if (!platform_message.type) {\n      platform_message.type = 'message';\n    }\n\n    next();\n  });\n  controller.defineBot(function (botkit, config) {\n    var bot = {\n      type: 'socket',\n      botkit: botkit,\n      config: config || {},\n      utterances: botkit.utterances\n    };\n\n    bot.startConversation = function (message, cb) {\n      botkit.startConversation(this, message, cb);\n    };\n\n    bot.createConversation = function (message, cb) {\n      botkit.createConversation(this, message, cb);\n    };\n\n    bot.send = function (message, cb) {\n      if (bot.connected || !bot.ws) {\n        if (bot.ws) {\n          try {\n            if (bot.ws && bot.ws.readyState === WebSocket.OPEN) {\n              bot.ws.send(JSON.stringify(message), function (err) {\n                if (cb) {\n                  return cb(err, message);\n                }\n              });\n            } else {\n              console.error('Cannot send message to closed socket');\n            }\n          } catch (err) {\n            return cb(err);\n          }\n        } else {\n          try {\n            bot.http_response.json(message);\n\n            if (cb) {\n              cb(null, message);\n            }\n          } catch (err) {\n            if (cb) {\n              return cb(err, message);\n            } else {\n              console.error('ERROR SENDING', err);\n            }\n          }\n        }\n      } else {\n        setTimeout(function () {\n          bot.send(message, cb);\n        }, 3000);\n      }\n    };\n\n    bot.startTyping = function () {\n      if (bot.connected) {\n        try {\n          if (bot.ws && bot.ws.readyState === WebSocket.OPEN) {\n            bot.ws.send(JSON.stringify({\n              type: 'typing'\n            }), function (err) {\n              if (err) {\n                console.error('startTyping failed: ' + err.message);\n              }\n            });\n          } else {\n            console.error('Socket closed! Cannot send message');\n          }\n        } catch (err) {\n          console.error('startTyping failed: ', err);\n        }\n      }\n    };\n\n    bot.typingDelay = function (message) {\n      return new Promise(function (resolve) {\n        var typingLength = 0;\n\n        if (message.typingDelay) {\n          typingLength = message.typingDelay;\n        } else {\n          var textLength;\n\n          if (message.text) {\n            textLength = message.text.length;\n          } else {\n            textLength = 80; //default attachment text length\n          }\n\n          var avgWPM = 150;\n          var avgCPM = avgWPM * 7;\n          typingLength = Math.min(Math.floor(textLength / (avgCPM / 60)) * 1000, 2000) * controller.config.typingDelayFactor;\n        }\n\n        setTimeout(function () {\n          resolve();\n        }, typingLength);\n      });\n    };\n\n    bot.replyWithTyping = function (src, resp, cb) {\n      bot.startTyping();\n      bot.typingDelay(resp).then(function () {\n        if (typeof resp == 'string') {\n          resp = {\n            text: resp\n          };\n        }\n\n        resp.user = src.user;\n        resp.channel = src.channel;\n        resp.to = src.user;\n        bot.say(resp, cb);\n      });\n    };\n\n    bot.reply = function (src, resp, cb) {\n      if (typeof resp == 'string') {\n        resp = {\n          text: resp\n        };\n      }\n\n      resp.user = src.user;\n      resp.channel = src.channel;\n      resp.to = src.user;\n\n      if (resp.typing || resp.typingDelay || controller.config.replyWithTyping) {\n        bot.replyWithTyping(src, resp, cb);\n      } else {\n        bot.say(resp, cb);\n      }\n    };\n\n    bot.findConversation = function (message, cb) {\n      botkit.debug('CUSTOM FIND CONVO', message.user, message.channel);\n\n      for (var t = 0; t < botkit.tasks.length; t++) {\n        for (var c = 0; c < botkit.tasks[t].convos.length; c++) {\n          if (botkit.tasks[t].convos[c].isActive() && botkit.tasks[t].convos[c].source_message.user == message.user && botkit.excludedEvents.indexOf(message.type) == -1 // this type of message should not be included\n          ) {\n              botkit.debug('FOUND EXISTING CONVO!');\n              cb(botkit.tasks[t].convos[c]);\n              return;\n            }\n        }\n      }\n\n      cb();\n    };\n    /*\n     * return info about the specific instance of this bot\n     * including identity information, and any other info that is relevant\n     */\n\n\n    bot.getInstanceInfo = function (cb) {\n      return new Promise(function (resolve) {\n        var instance = {\n          identity: {},\n          team: {}\n        };\n\n        if (bot.identity) {\n          instance.identity.name = bot.identity.name;\n          instance.identity.id = bot.identity.id;\n          instance.team.name = bot.identity.name;\n          instance.team.url = bot.identity.root_url;\n          instance.team.id = bot.identity.name;\n        } else {\n          instance.identity.name = 'Botkit Web';\n          instance.identity.id = 'web';\n        }\n\n        if (cb) cb(null, instance);\n        resolve(instance);\n      });\n    };\n\n    bot.getMessageUser = function (message, cb) {\n      return new Promise(function (resolve) {\n        // normalize this into what botkit wants to see\n        controller.storage.users.get(message.user, function (err, user) {\n          if (!user) {\n            user = {\n              id: message.user,\n              name: 'Unknown',\n              attributes: {}\n            };\n          }\n\n          var profile = {\n            id: user.id,\n            username: user.name,\n            first_name: user.attributes.first_name || '',\n            last_name: user.attributes.last_name || '',\n            full_name: user.attributes.full_name || '',\n            email: user.attributes.email,\n            // may be blank\n            gender: user.attributes.gender,\n            // no source for this info\n            timezone_offset: user.attributes.timezone_offset,\n            timezone: user.attributes.timezone\n          };\n\n          if (cb) {\n            cb(null, profile);\n          }\n\n          resolve(profile);\n        });\n      });\n    };\n\n    return bot;\n  });\n\n  controller.handleWebhookPayload = function (req, res) {\n    var payload = req.body;\n    controller.ingest(controller.spawn({}), payload, res);\n  }; // change the speed of typing a reply in a conversation\n\n\n  controller.setTypingDelayFactor = function (delayFactor) {\n    controller.config.typingDelayFactor = delayFactor;\n  }; // Substantially shorten the delay for processing messages in conversations\n\n\n  controller.setTickDelay(10);\n  return controller;\n}\n\nmodule.exports = WebBot;","map":null,"metadata":{},"sourceType":"module"}