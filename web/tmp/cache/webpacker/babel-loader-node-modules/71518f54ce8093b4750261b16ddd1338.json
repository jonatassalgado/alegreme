{"ast":null,"code":"/**\n * This is a module that makes a bot\n * It expects to receive messages via the botkit.ingest function\n *\n */\nvar mustache = require('mustache');\n\nvar simple_storage = require(__dirname + '/storage/simple_storage.js');\n\nvar ConsoleLogger = require(__dirname + '/console_logger.js');\n\nvar LogLevels = ConsoleLogger.LogLevels;\n\nvar ware = require('ware');\n\nvar clone = require('clone');\n\nvar studio = require('./Studio.js');\n\nvar os = require('os');\n\nvar async = require('async');\n\nvar PKG_VERSION = require('../package.json').version;\n\nvar express = require('express');\n\nvar bodyParser = require('body-parser');\n\nvar utils = require('./Utils.js');\n\nfunction Botkit(configuration) {\n  var botkit = {\n    events: {},\n    // this will hold event handlers\n    config: {},\n    // this will hold the configuration\n    tasks: [],\n    taskCount: 0,\n    convoCount: 0,\n    my_version: null,\n    my_user_agent: null,\n    memory_store: {\n      users: {},\n      channels: {},\n      teams: {}\n    },\n    tickDelay: 1500\n  };\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n  botkit.utterances = utils.getUtterances();\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n  /*\n   * define some middleware points where custom functions\n   * can plug into key points of botkits process\n   */\n\n  botkit.middleware = {\n    spawn: ware(),\n    ingest: ware(),\n    normalize: ware(),\n    categorize: ware(),\n    receive: ware(),\n    heard: ware(),\n    // best place for heavy i/o because fewer messages\n    triggered: ware(),\n    // like heard, but for other events\n    capture: ware(),\n    format: ware(),\n    send: ware(),\n    conversationStart: ware(),\n    conversationEnd: ware()\n  };\n  /*\n   * list of events to exclude from conversations\n   * useful to exclude things like delivery confirmations, and other behind the scenes events\n   */\n\n  botkit.excludedEvents = []; // add a single event or an array of events to be excluded from the conversations\n\n  botkit.excludeFromConversations = function (event) {\n    if (Array.isArray(event)) {\n      for (var e = 0; e < event.length; e++) {\n        botkit.excludedEvents.push(event[e]);\n      }\n    } else {\n      botkit.excludedEvents.push(event);\n    }\n  };\n\n  botkit.ingest = function (obot, opayload, source) {\n    // keep an unmodified copy of the message\n    opayload.raw_message = clone(opayload);\n    opayload._pipeline = {\n      stage: 'ingest'\n    };\n    botkit.middleware.ingest.run(obot, opayload, source, function (err, bot, payload) {\n      if (err) {\n        console.error('An error occurred in the ingest middleware: ', err);\n        botkit.trigger('ingest_error', [err, obot, opayload]);\n        botkit.trigger('pipeline_error', [err, obot, opayload, 'ingest']);\n        return;\n      }\n\n      botkit.normalize(bot, payload);\n    });\n  };\n\n  botkit.normalize = function (obot, opayload) {\n    opayload._pipeline.stage = 'normalize';\n    botkit.middleware.normalize.run(obot, opayload, function (err, bot, message) {\n      if (err) {\n        console.error('An error occurred in the normalize middleware: ', err);\n        botkit.trigger('normalize_error', [err, obot, opayload]);\n        botkit.trigger('pipeline_error', [err, obot, opayload, 'normalize']);\n        return;\n      }\n\n      if (!message.type) {\n        message.type = 'message_received';\n      }\n\n      botkit.categorize(bot, message);\n    });\n  };\n\n  botkit.categorize = function (obot, omessage) {\n    omessage._pipeline.stage = 'categorize';\n    botkit.middleware.categorize.run(obot, omessage, function (err, bot, message) {\n      if (err) {\n        console.error('An error occurred in the categorize middleware: ', err);\n        botkit.trigger('categorize_error', [err, obot, omessage]);\n        botkit.trigger('pipeline_error', [err, obot, omessage, 'categorize']);\n        return;\n      }\n\n      botkit.receiveMessage(bot, message);\n    });\n  };\n\n  botkit.receiveMessage = function (obot, omessage) {\n    omessage._pipeline.stage = 'receive';\n    botkit.middleware.receive.run(obot, omessage, function (err, bot, message) {\n      if (err) {\n        // log the error to console, so people recognize it\n        console.error('An error occurred in the receive middleware: ', err);\n        /*\n         * an error occured in the receive middleware\n         * fire the error event instead of disposing the message\n         * can be obtained by using controller.on('receive_error')[...]\n         */\n\n        botkit.trigger('receive_error', [err, obot, omessage]);\n        botkit.trigger('pipeline_error', [err, obot, omessage, 'receive']);\n      } else {\n        botkit.debug('RECEIVED MESSAGE');\n        bot.findConversation(message, function (convo) {\n          if (convo) {\n            convo.handle(message);\n          } else {\n            botkit.trigger(message.type, [obot, omessage]);\n          }\n        });\n      }\n    });\n  };\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n\n  function Conversation(task, message) {\n    this.messages = [];\n    this.sent = [];\n    this.transcript = [];\n    this.context = {\n      user: message.user,\n      channel: message.channel,\n      bot: task.bot,\n      script_name: message.script_name || null,\n      script_id: message.script_id || null\n    };\n    this.events = {};\n    this.vars = {};\n    this.threads = {};\n    this.thread = null;\n    this.status = 'new';\n    this.task = task;\n    this.source_message = message;\n    this.handler = null;\n    this.responses = {};\n    this.capture_options = {};\n    this.startTime = new Date();\n    this.lastActive = new Date();\n    /**\n     * will be pointing to a callback which will be called after timeout,\n     * conversation will be not be ended and should be taken care by callback\n     */\n\n    this.timeOutHandler = null;\n\n    this.collectResponse = function (key, value) {\n      this.responses[key] = value;\n    };\n\n    this.capture = function (response, cb) {\n      var that = this;\n      var capture_key = this.sent[this.sent.length - 1].text;\n      botkit.middleware.capture.run(that.task.bot, response, that, function (err, bot, response) {\n        if (response.text) {\n          response.text = response.text.trim();\n        } else {\n          response.text = '';\n        }\n\n        if (that.capture_options.key != undefined) {\n          capture_key = that.capture_options.key;\n        }\n        /*\n         * capture the question that was asked\n         * if text is an array, get 1st\n         */\n\n\n        if (typeof that.sent[that.sent.length - 1].text == 'string') {\n          response.question = that.sent[that.sent.length - 1].text;\n        } else if (Array.isArray(that.sent[that.sent.length - 1].text)) {\n          response.question = that.sent[that.sent.length - 1].text[0];\n        } else {\n          response.question = '';\n        }\n\n        if (that.capture_options.multiple) {\n          if (!that.responses[capture_key]) {\n            that.responses[capture_key] = [];\n          }\n\n          that.responses[capture_key].push(response);\n        } else {\n          that.responses[capture_key] = response;\n        }\n\n        if (cb) cb(response);\n      });\n    };\n\n    this.handle = function (message) {\n      var that = this;\n      this.lastActive = new Date();\n      this.transcript.push(message);\n      botkit.debug('HANDLING MESSAGE IN CONVO', message); // do other stuff like call custom callbacks\n\n      if (this.handler) {\n        this.capture(message, function (message) {\n          /*\n           * if the handler is a normal function, just execute it!\n           * NOTE: anyone who passes in their own handler has to call\n           * convo.next() to continue after completing whatever it is they want to do.\n           */\n          if (typeof that.handler == 'function') {\n            that.handler(message, that);\n          } else {\n            /*\n             * handle might be a mapping of keyword to callback.\n             * lets see if the message matches any of the keywords\n             */\n            var patterns = that.handler;\n\n            for (var p = 0; p < patterns.length; p++) {\n              if (patterns[p].pattern && botkit.hears_test([patterns[p].pattern], message)) {\n                botkit.middleware.heard.run(that.task.bot, message, function (err, bot, message) {\n                  patterns[p].callback(message, that);\n                });\n                return;\n              }\n            }\n            /*\n             * none of the messages matched! What do we do?\n             * if a default exists, fire it!\n             */\n\n\n            for (var p = 0; p < patterns.length; p++) {\n              if (patterns[p].default) {\n                botkit.middleware.heard.run(that.task.bot, message, function (err, bot, message) {\n                  patterns[p].callback(message, that);\n                });\n                return;\n              }\n            }\n          }\n        });\n      } else {// do nothing\n      }\n    };\n\n    this.setVar = function (field, value) {\n      if (!this.vars) {\n        this.vars = {};\n      }\n\n      this.vars[field] = value;\n    };\n\n    this.activate = function () {\n      botkit.middleware.conversationStart.run(this.task.bot, this, function (err, bot, convo) {\n        convo.status = 'active';\n        convo.task.trigger('conversationStarted', [convo]);\n        convo.task.botkit.trigger('conversationStarted', [bot, convo]);\n      });\n    };\n    /**\n     * active includes both ACTIVE and ENDING\n     * in order to allow the timeout end scripts to play out\n     *\n     */\n\n\n    this.isActive = function () {\n      return this.status == 'active' || this.status == 'ending';\n    };\n\n    this.deactivate = function () {\n      this.status = 'inactive';\n    };\n\n    this.say = function (message) {\n      this.addMessage(message);\n    };\n\n    this.addConditional = function (condition, thread) {\n      condition.type = 'conditional';\n\n      if (!this.threads[thread]) {\n        this.threads[thread] = [];\n      }\n\n      this.threads[thread].push(condition); // this is the current topic, so add it here as well\n\n      if (this.thread == thread) {\n        this.messages.push(condition);\n      }\n    };\n\n    this.handleAction = function (condition) {\n      /*\n       * condition.action\n       * if (condition.action=='execute_script')\n       * condition.execute will be present\n       */\n      var that = this;\n\n      switch (condition.action) {\n        case 'execute_script':\n          if (condition.execute) {\n            var script = condition.execute.script;\n            var thread = condition.execute.thread; // this will stop the conversation from automatically ending while the transition takes place\n\n            that.status = 'transitioning';\n            botkit.studio.get(that.context.bot, script, that.source_message.user, that.source_message.channel, that.source_message).then(function (new_convo) {\n              that.context.transition_to = new_convo.context.script_name || null;\n              that.context.transition_to_id = new_convo.context.script_id || null;\n              that.stop('transitioning to ' + script); // copy any question responses\n\n              for (var key in that.responses) {\n                new_convo.responses[key] = that.responses[key];\n              } // copy old variables into new conversation\n\n\n              for (var key in that.vars) {\n                new_convo.setVar(key, that.vars[key]);\n              }\n\n              new_convo.context.transition_from = that.context.script_name || null;\n              new_convo.context.transition_from_id = that.context.script_id || null;\n              /*\n               * if thread == default, this is the normal behavior and we don't need to call gotoThread\n               * in fact, calling gotoThread will cause it to override behaviors in the scripts `before` hook.\n               */\n\n              if (thread != 'default') {\n                new_convo.gotoThread(thread);\n              }\n\n              new_convo.activate();\n            }).catch(function (err) {\n              console.error('Error executing script transition:', err);\n            });\n          }\n\n          break;\n\n        case 'next':\n          that.next();\n          break;\n\n        case 'repeat':\n          that.repeat();\n          that.next();\n          break;\n\n        case 'stop':\n          that.stop();\n          break;\n\n        case 'wait':\n          that.silentRepeat();\n          break;\n\n        case 'complete':\n          that.stop('completed');\n          break;\n\n        case 'timeout':\n          that.stop('timeout');\n          break;\n\n        default:\n          if (typeof condition.action == 'function') {\n            condition.action(that);\n          } else {\n            that.gotoThread(condition.action);\n          }\n\n          break;\n      }\n    };\n\n    this.evaluateCondition = function (condition) {\n      var that = this;\n      var left = this.replaceTokens(condition.left);\n      var right = this.replaceTokens(condition.right);\n      var passed = false;\n\n      switch (condition.test) {\n        case 'equals':\n          if (left == right) {\n            // immediately move on!\n            passed = true;\n          }\n\n          break;\n\n        case '!equals':\n          if (left != right) {\n            // immediately move on!\n            passed = true;\n          }\n\n          break;\n\n        case 'exists':\n          if (left && left != '') {\n            // immediately move on!\n            passed = true;\n          }\n\n          break;\n\n        case '!exists':\n          if (!left || left == '') {\n            // immediately move on!\n            passed = true;\n          }\n\n          break;\n      }\n\n      if (passed) {\n        that.handleAction(condition);\n      }\n\n      this.tick();\n    };\n\n    this.sayFirst = function (message) {\n      if (typeof message == 'string') {\n        message = {\n          text: message,\n          channel: this.source_message.channel\n        };\n      } else {\n        message.channel = this.source_message.channel;\n      }\n\n      this.messages.unshift(message);\n    };\n\n    this.on = function (event, cb) {\n      botkit.debug('Setting up a handler for', event);\n      var events = event.split(/\\,/g); // Trim any whitespace out of the event name.\n\n      events = events.map(function (event) {\n        return event.trim();\n      });\n\n      for (var e in events) {\n        if (!this.events[events[e]]) {\n          this.events[events[e]] = [];\n        }\n\n        this.events[events[e]].push(cb);\n      }\n\n      return this;\n    };\n\n    this.trigger = function (event, data) {\n      if (this.events[event]) {\n        for (var e = 0; e < this.events[event].length; e++) {\n          var res = this.events[event][e].apply(this, data);\n\n          if (res === false) {\n            return;\n          }\n        }\n      }\n    }; // proceed to the next message after waiting for an answer\n\n\n    this.next = function () {\n      this.handler = null;\n    };\n\n    this.repeat = function () {\n      if (this.sent.length) {\n        /*\n         * is this the last message in the queue? then just push it on again\n         * if not, sayFirst it to the front so it doesn't repeat AFTER other messages\n         */\n        if (!this.messages.length) {\n          this.messages.push(this.sent[this.sent.length - 1]);\n        } else {\n          this.sayFirst(this.sent[this.sent.length - 1]);\n        }\n      } else {// do nothing\n      }\n    };\n\n    this.silentRepeat = function () {\n      return;\n    };\n\n    this.addQuestion = function (message, cb, capture_options, thread) {\n      if (typeof message == 'string') {\n        message = {\n          text: message,\n          channel: this.source_message.channel\n        };\n      } else {\n        message.channel = this.source_message.channel;\n      }\n\n      if (capture_options) {\n        message.capture_options = capture_options;\n      }\n\n      message.handler = cb;\n      this.addMessage(message, thread);\n    };\n\n    this.ask = function (message, cb, capture_options) {\n      this.addQuestion(message, cb, capture_options, this.thread || 'default');\n    };\n\n    this.addMessage = function (message, thread) {\n      if (!thread) {\n        thread = this.thread;\n      }\n\n      if (typeof message == 'string') {\n        message = {\n          text: message,\n          channel: this.source_message.channel\n        };\n      } else {\n        message.channel = this.source_message.channel;\n      }\n\n      if (!this.threads[thread]) {\n        this.threads[thread] = [];\n      }\n\n      this.threads[thread].push(message); // this is the current topic, so add it here as well\n\n      if (this.thread == thread) {\n        this.messages.push(message);\n      }\n    }; // how long should the bot wait while a user answers?\n\n\n    this.setTimeout = function (timeout) {\n      this.task.timeLimit = timeout;\n    }; // For backwards compatibility, wrap gotoThread in its previous name\n\n\n    this.changeTopic = function (topic) {\n      this.gotoThread(topic);\n    };\n\n    this.hasThread = function (thread) {\n      return this.threads[thread] != undefined;\n    };\n\n    this.transitionTo = function (thread, message) {\n      /*\n       * add a new transition thread\n       * add this new message to it\n       * set that message action to execute the actual transition\n       * then change threads to transition thread\n       */\n      var num = 1;\n\n      while (this.hasThread('transition_' + num)) {\n        num++;\n      }\n\n      var threadname = 'transition_' + num;\n\n      if (typeof message == 'string') {\n        message = {\n          text: message,\n          action: thread\n        };\n      } else {\n        message.action = thread;\n      }\n\n      this.addMessage(message, threadname);\n      this.gotoThread(threadname);\n    };\n\n    this.beforeThread = function (thread, callback) {\n      if (!this.before_hooks) {\n        this.before_hooks = {};\n      }\n\n      if (!this.before_hooks[thread]) {\n        this.before_hooks[thread] = [];\n      }\n\n      this.before_hooks[thread].push(callback);\n    };\n\n    this.gotoThread = function (thread) {\n      var that = this;\n      that.next_thread = thread;\n      that.processing = true;\n\n      var makeChange = function makeChange() {\n        if (!that.hasThread(that.next_thread)) {\n          if (that.next_thread == 'default') {\n            that.threads[that.next_thread] = [];\n          } else {\n            botkit.debug('WARN: gotoThread() to an invalid thread!', thread);\n            that.stop('unknown_thread');\n            return;\n          }\n        }\n\n        that.thread = that.next_thread;\n        that.messages = that.threads[that.next_thread].slice();\n        that.handler = null;\n        that.processing = false;\n      };\n\n      if (that.before_hooks && that.before_hooks[that.next_thread]) {\n        // call any beforeThread hooks in sequence\n        async.eachSeries(this.before_hooks[that.next_thread], function (before_hook, next) {\n          before_hook(that, next);\n        }, function (err) {\n          if (!err) {\n            makeChange();\n          }\n        });\n      } else {\n        makeChange();\n      }\n    };\n\n    this.combineMessages = function (messages) {\n      if (!messages) {\n        return '';\n      }\n\n      if (Array.isArray(messages) && !messages.length) {\n        return '';\n      }\n\n      if (messages.length > 1) {\n        var txt = [];\n        var last_user = null;\n        var multi_users = false;\n        last_user = messages[0].user;\n\n        for (var x = 0; x < messages.length; x++) {\n          if (messages[x].user != last_user) {\n            multi_users = true;\n          }\n        }\n\n        last_user = '';\n\n        for (var x = 0; x < messages.length; x++) {\n          if (multi_users && messages[x].user != last_user) {\n            last_user = messages[x].user;\n\n            if (txt.length) {\n              txt.push('');\n            }\n\n            txt.push('<@' + messages[x].user + '>:');\n          }\n\n          txt.push(messages[x].text);\n        }\n\n        return txt.join('\\n');\n      } else {\n        if (messages.length) {\n          return messages[0].text;\n        } else {\n          return messages.text;\n        }\n      }\n    };\n\n    this.getResponses = function () {\n      var res = {};\n\n      for (var key in this.responses) {\n        res[key] = {\n          question: this.responses[key].length ? this.responses[key][0].question : this.responses[key].question,\n          key: key,\n          answer: this.extractResponse(key)\n        };\n      }\n\n      return res;\n    };\n\n    this.getResponsesAsArray = function () {\n      var res = [];\n\n      for (var key in this.responses) {\n        res.push({\n          question: this.responses[key].length ? this.responses[key][0].question : this.responses[key].question,\n          key: key,\n          answer: this.extractResponse(key)\n        });\n      }\n\n      return res;\n    };\n\n    this.extractResponses = function () {\n      var res = {};\n\n      for (var key in this.responses) {\n        res[key] = this.extractResponse(key);\n      }\n\n      return res;\n    };\n\n    this.extractResponse = function (key) {\n      return this.combineMessages(this.responses[key]);\n    };\n\n    this.replaceAttachmentTokens = function (attachments) {\n      if (attachments && attachments.length) {\n        for (var a = 0; a < attachments.length; a++) {\n          for (var key in attachments[a]) {\n            if (typeof attachments[a][key] == 'string') {\n              attachments[a][key] = this.replaceTokens(attachments[a][key]);\n            } else {\n              attachments[a][key] = this.replaceAttachmentTokens(attachments[a][key]);\n            }\n          }\n        }\n      } else {\n        for (var a in attachments) {\n          if (typeof attachments[a] == 'string') {\n            attachments[a] = this.replaceTokens(attachments[a]);\n          } else {\n            attachments[a] = this.replaceAttachmentTokens(attachments[a]);\n          }\n        }\n      }\n\n      return attachments;\n    };\n\n    this.replaceTokens = function (text) {\n      var vars = {\n        identity: this.task.bot.identity,\n        responses: this.extractResponses(),\n        origin: this.task.source_message,\n        vars: this.vars\n      };\n      var rendered = '';\n\n      try {\n        rendered = mustache.render(text, vars);\n      } catch (err) {\n        botkit.log('Error in message template. Mustache failed with error: ', err);\n        rendered = text;\n      }\n\n      return rendered;\n    };\n\n    this.stop = function (status) {\n      this.handler = null;\n      this.messages = [];\n      this.status = status || 'stopped';\n      botkit.debug('Conversation is over with status ' + this.status);\n      this.task.conversationEnded(this);\n    };\n    /*\n     * was this conversation successful?\n     * return true if it was completed\n     * otherwise, return false\n     * false could indicate a variety of failed states:\n     * manually stopped, timed out, etc\n     */\n\n\n    this.successful = function () {\n      // if the conversation is still going, it can't be successful yet\n      if (this.isActive()) {\n        return false;\n      }\n\n      if (this.status == 'completed') {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    this.cloneMessage = function (message) {\n      // clone this object so as not to modify source\n      var outbound = clone(message);\n\n      if (typeof message.text == 'string') {\n        outbound.text = this.replaceTokens(message.text);\n      } else if (message.text) {\n        outbound.text = this.replaceTokens(message.text[Math.floor(Math.random() * message.text.length)]);\n      }\n\n      if (outbound.attachments) {\n        outbound.attachments = this.replaceAttachmentTokens(outbound.attachments);\n      }\n\n      if (outbound.attachment) {\n        // pick one variation of the message text at random\n        if (outbound.attachment.payload.text && typeof outbound.attachment.payload.text != 'string') {\n          outbound.attachment.payload.text = this.replaceTokens(outbound.attachment.payload.text[Math.floor(Math.random() * outbound.attachment.payload.text.length)]);\n        }\n\n        outbound.attachment = this.replaceAttachmentTokens([outbound.attachment])[0];\n      }\n\n      if (this.messages.length && !message.handler) {\n        outbound.continue_typing = true;\n      }\n\n      if (typeof message.attachments == 'function') {\n        outbound.attachments = message.attachments(this);\n      }\n\n      return outbound;\n    };\n\n    this.onTimeout = function (handler) {\n      if (typeof handler == 'function') {\n        this.timeOutHandler = handler;\n      } else {\n        botkit.debug('Invalid timeout function passed to onTimeout');\n      }\n    };\n\n    this.tick = function () {\n      var now = new Date();\n\n      if (this.isActive()) {\n        if (this.processing) {// do nothing. The bot is waiting for async process to complete.\n        } else if (this.handler) {\n          /*\n           * check timeout!\n           * how long since task started?\n           */\n          var duration = now.getTime() - this.task.startTime.getTime(); // how long since last active?\n\n          var lastActive = now.getTime() - this.lastActive.getTime();\n\n          if (this.task.timeLimit && // has a timelimit\n          duration > this.task.timeLimit && // timelimit is up\n          lastActive > this.task.timeLimit // nobody has typed for 60 seconds at least\n          ) {\n              /*\n               * if timeoutHandler is set then call it, otherwise follow the normal flow\n               * this will not break others code, after the update\n               */\n              if (this.timeOutHandler) {\n                this.timeOutHandler(this);\n              } else if (this.hasThread('on_timeout')) {\n                this.status = 'ending';\n                this.gotoThread('on_timeout');\n              } else {\n                this.stop('timeout');\n              }\n            } // otherwise do nothing\n\n        } else {\n          if (this.messages.length) {\n            if (this.sent.length && !this.sent[this.sent.length - 1].sent) {\n              return;\n            }\n\n            if (this.task.bot.botkit.config.require_delivery && this.sent.length && !this.sent[this.sent.length - 1].delivered) {\n              return;\n            }\n            /*\n             * make sure the first message is delayed appropriately.\n             * this comes into play when the thread changes or the conversation starts.\n             * we need to set the delay based on NOW.\n             */\n\n\n            if (this.messages.length && this.messages[0].delay && !this.messages[0].timestamp) {\n              this.messages[0].timestamp = now.getTime() + this.messages[0].delay;\n            }\n\n            if (typeof this.messages[0].timestamp == 'undefined' || this.messages[0].timestamp <= now.getTime()) {\n              var message = this.messages.shift();\n              /*\n               * make sure next message is delayed appropriately\n               * this will offset the NEXT message from the SEND time.\n               */\n\n              if (this.messages.length && this.messages[0].delay) {\n                this.messages[0].timestamp = now.getTime() + parseInt(this.messages[0].delay);\n              }\n\n              if (message.conditional) {\n                this.evaluateCondition(message.conditional);\n                /*\n                 * we want to stop processing this message\n                 * because evaluate conditional can process a bunch of stuff\n                 * and then move on to the next step internally\n                 */\n\n                return;\n              } else {\n                if (message.handler) {\n                  this.handler = message.handler;\n                } else {\n                  this.handler = null;\n                }\n\n                if (message.capture_options) {\n                  this.capture_options = message.capture_options;\n                } else {\n                  this.capture_options = {};\n                }\n\n                this.lastActive = new Date();\n                /*\n                 * is there any text?\n                 * or an attachment? (facebook)\n                 * or multiple attachments (slack)\n                 */\n\n                if (message.text || message.attachments || message.attachment) {\n                  var outbound = this.cloneMessage(message);\n                  var that = this;\n                  outbound.sent_timestamp = new Date().getTime();\n                  that.sent.push(outbound);\n                  that.transcript.push(outbound);\n                  this.task.bot.reply(this.source_message, outbound, function (err, sent_message) {\n                    if (err) {\n                      botkit.log('An error occurred while sending a message: ', err);\n                      /*\n                       * even though an error occurred, set sent to true\n                       * this will allow the conversation to keep going even if one message fails\n                       * TODO: make a message that fails to send _resend_ at least once\n                       */\n\n                      that.sent[that.sent.length - 1].sent = true;\n                      that.sent[that.sent.length - 1].api_response = err;\n                    } else {\n                      that.sent[that.sent.length - 1].sent = true;\n                      that.sent[that.sent.length - 1].api_response = sent_message;\n                      /*\n                       * if sending via slack's web api, there is no further confirmation\n                       * so we can mark the message delivered\n                       */\n\n                      if (that.task.bot.type == 'slack' && sent_message && sent_message.ts) {\n                        that.sent[that.sent.length - 1].delivered = true;\n                      }\n\n                      that.trigger('sent', [sent_message]);\n                    }\n                  });\n                }\n\n                if (message.action) {\n                  this.handleAction(message);\n                }\n              } // if not conditional\n\n            } else {} // do nothing\n\n              /*\n               * end immediately instead of waiting til next tick.\n               * if it hasn't already been ended by a message action!\n               */\n\n\n            if (this.isActive() && !this.messages.length && !this.handler && !this.processing) {\n              this.stop('completed');\n            }\n          } else if (this.sent.length) {\n            // sent at least 1 message\n            this.stop('completed');\n          }\n        }\n      }\n    };\n\n    botkit.debug('CREATED A CONVO FOR', this.source_message.user, this.source_message.channel);\n    this.gotoThread('default');\n  }\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n\n  function Task(bot, message, botkit) {\n    this.convos = [];\n    this.botkit = botkit;\n    this.bot = bot;\n    this.events = {};\n    this.source_message = message;\n    this.status = 'active';\n    this.startTime = new Date();\n\n    this.isActive = function () {\n      return this.status == 'active';\n    };\n\n    this.createConversation = function (message) {\n      var convo = new Conversation(this, message);\n      convo.id = botkit.convoCount++;\n      this.convos.push(convo);\n      return convo;\n    };\n\n    this.startConversation = function (message) {\n      var convo = this.createConversation(message);\n      botkit.debug('>   [Start] ', convo.id, ' Conversation with ', message.user, 'in', message.channel);\n      convo.activate();\n      return convo;\n    };\n\n    this.conversationEnded = function (convo) {\n      var that = this;\n      botkit.middleware.conversationEnd.run(this.bot, convo, function (err, bot, convo) {\n        botkit.debug('>   [End] ', convo.id, ' Conversation with ', convo.source_message.user, 'in', convo.source_message.channel);\n        that.trigger('conversationEnded', [convo]);\n        that.botkit.trigger('conversationEnded', [bot, convo]);\n        convo.trigger('end', [convo]);\n        var actives = 0;\n\n        for (var c = 0; c < that.convos.length; c++) {\n          if (that.convos[c].isActive()) {\n            actives++;\n          }\n        }\n\n        if (actives == 0) {\n          that.taskEnded();\n        }\n      });\n    };\n\n    this.endImmediately = function (reason) {\n      for (var c = 0; c < this.convos.length; c++) {\n        if (this.convos[c].isActive()) {\n          this.convos[c].stop(reason || 'stopped');\n        }\n      }\n    };\n\n    this.taskEnded = function () {\n      botkit.debug('[End] ', this.id, ' Task for ', this.source_message.user, 'in', this.source_message.channel);\n      this.status = 'completed';\n      this.trigger('end', [this]);\n    };\n\n    this.on = function (event, cb) {\n      botkit.debug('Setting up a handler for', event);\n      var events = event.split(/\\,/g); // Trim any whitespace out of the event name.\n\n      events = events.map(function (event) {\n        return event.trim();\n      });\n\n      for (var e in events) {\n        if (!this.events[events[e]]) {\n          this.events[events[e]] = [];\n        }\n\n        this.events[events[e]].push(cb);\n      }\n\n      return this;\n    };\n\n    this.trigger = function (event, data) {\n      if (this.events[event]) {\n        for (var e = 0; e < this.events[event].length; e++) {\n          var res = this.events[event][e].apply(this, data);\n\n          if (res === false) {\n            return;\n          }\n        }\n      }\n    };\n\n    this.getResponsesByUser = function () {\n      var users = {};\n      /*\n       * go through all conversations\n       * extract normalized answers\n       */\n\n      for (var c = 0; c < this.convos.length; c++) {\n        var user = this.convos[c].source_message.user;\n        users[this.convos[c].source_message.user] = {};\n        var convo = this.convos[c];\n        users[user] = convo.extractResponses();\n      }\n\n      return users;\n    };\n\n    this.getResponsesBySubject = function () {\n      var answers = {};\n      /*\n       * go through all conversations\n       * extract normalized answers\n       */\n\n      for (var c = 0; c < this.convos.length; c++) {\n        var convo = this.convos[c];\n\n        for (var key in convo.responses) {\n          if (!answers[key]) {\n            answers[key] = {};\n          }\n\n          answers[key][convo.source_message.user] = convo.extractResponse(key);\n        }\n      }\n\n      return answers;\n    };\n\n    this.tick = function () {\n      for (var c = 0; c < this.convos.length; c++) {\n        if (this.convos[c].isActive()) {\n          this.convos[c].tick();\n        }\n      }\n    };\n  }\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n\n  botkit.storage = {\n    teams: {\n      get: function get(team_id, cb) {\n        cb(null, botkit.memory_store.teams[team_id]);\n      },\n      save: function save(team, cb) {\n        if (team.id) {\n          botkit.memory_store.teams[team.id] = team;\n          cb(null, team.id);\n        } else {\n          cb('No ID specified');\n        }\n      },\n      delete: function _delete(team_id, cb) {\n        delete botkit.memory_store.teams[team_id];\n        cb();\n      },\n      all: function all(cb) {\n        cb(null, botkit.memory_store.teams);\n      }\n    },\n    users: {\n      get: function get(user_id, cb) {\n        cb(null, botkit.memory_store.users[user_id]);\n      },\n      save: function save(user, cb) {\n        if (user.id) {\n          botkit.memory_store.users[user.id] = user;\n          cb(null, user.id);\n        } else {\n          cb('No ID specified');\n        }\n      },\n      delete: function _delete(user_id, cb) {\n        delete botkit.memory_store.users[user_id];\n        cb();\n      },\n      all: function all(cb) {\n        cb(null, botkit.memory_store.users);\n      }\n    },\n    channels: {\n      get: function get(channel_id, cb) {\n        cb(null, botkit.memory_store.channels[channel_id]);\n      },\n      save: function save(channel, cb) {\n        if (channel.id) {\n          botkit.memory_store.channels[channel.id] = channel;\n          cb(null, channel.id);\n        } else {\n          cb('No ID specified');\n        }\n      },\n      delete: function _delete(user_id, cb) {\n        delete botkit.memory_store.channels[channel_id];\n        cb();\n      },\n      all: function all(cb) {\n        cb(null, botkit.memory_store.channels);\n      }\n    }\n  };\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n  /**\n   * hears_regexp - default string matcher uses regular expressions\n   *\n   * @param  {array}  tests    patterns to match\n   * @param  {object} message message object with various fields\n   * @return {boolean}        whether or not a pattern was matched\n   */\n\n  botkit.hears_regexp = function (tests, message) {\n    for (var t = 0; t < tests.length; t++) {\n      if (message.text) {\n        /*\n         * the pattern might be a string to match (including regular expression syntax)\n         * or it might be a prebuilt regular expression\n         */\n        var test = null;\n\n        if (typeof tests[t] == 'string') {\n          try {\n            test = new RegExp(tests[t], 'i');\n          } catch (err) {\n            botkit.log('Error in regular expression: ' + tests[t] + ': ' + err);\n            return false;\n          }\n\n          if (!test) {\n            return false;\n          }\n        } else {\n          test = tests[t];\n        }\n\n        var match = message.text.match(test);\n\n        if (match) {\n          message.match = match;\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * changeEars - change the default matching function\n   *\n   * @param  {function} new_test a function that accepts (tests, message) and returns a boolean\n   */\n\n\n  botkit.changeEars = function (new_test) {\n    botkit.hears_test = new_test;\n  };\n\n  botkit.hears = function (keywords, events, middleware_or_cb, cb) {\n    /*\n     * the third parameter is EITHER a callback handler\n     * or a middleware function that redefines how the hear works\n     */\n    var test_function = botkit.hears_test;\n\n    if (cb) {\n      test_function = middleware_or_cb;\n    } else {\n      cb = middleware_or_cb;\n    }\n\n    if (typeof keywords == 'string') {\n      keywords = [keywords];\n    }\n\n    if (keywords instanceof RegExp) {\n      keywords = [keywords];\n    }\n\n    if (typeof events == 'string') {\n      events = events.split(/\\,/g).map(function (str) {\n        return str.trim();\n      });\n    }\n\n    for (var e = 0; e < events.length; e++) {\n      (function (keywords, test_function) {\n        botkit.on(events[e], function (bot, message) {\n          if (test_function && test_function(keywords, message)) {\n            botkit.debug('I HEARD', keywords);\n            botkit.middleware.heard.run(bot, message, function (err, bot, message) {\n              cb.apply(this, [bot, message]);\n              botkit.trigger('heard_trigger', [bot, keywords, message]);\n            });\n            return false;\n          }\n        }, true);\n      })(keywords, test_function);\n    }\n\n    return this;\n  };\n\n  botkit.on = function (event, cb, is_hearing) {\n    botkit.debug('Setting up a handler for', event);\n    var events = typeof event == 'string' ? event.split(/\\,/g) : event; // Trim any whitespace out of the event name.\n\n    events = events.map(function (event) {\n      return event.trim();\n    });\n\n    for (var e in events) {\n      if (!this.events[events[e]]) {\n        this.events[events[e]] = [];\n      }\n\n      this.events[events[e]].push({\n        callback: cb,\n        type: is_hearing ? 'hearing' : 'event'\n      });\n    }\n\n    return this;\n  };\n\n  botkit.trigger = function (event, data) {\n    if (this.events[event]) {\n      var hearing = this.events[event].filter(function (e) {\n        return e.type == 'hearing';\n      });\n      var handlers = this.events[event].filter(function (e) {\n        return e.type != 'hearing';\n      });\n      /*\n       * first, look for hearing type events\n       * these are always handled before normal event handlers\n       */\n\n      for (var e = 0; e < hearing.length; e++) {\n        var res = hearing[e].callback.apply(this, data);\n\n        if (res === false) {\n          return;\n        }\n      }\n      /*\n       * now, if we haven't already heard something,\n       * fire the remaining event handlers\n       */\n\n\n      if (handlers.length) {\n        // eslint-disable-next-line no-unused-vars\n        botkit.middleware.triggered.run(data[0], data[1], function (err, bot, message) {\n          for (var e = 0; e < handlers.length; e++) {\n            var res = handlers[e].callback.apply(this, data);\n\n            if (res === false) {\n              return;\n            }\n          }\n        });\n      }\n    }\n  };\n\n  botkit.startConversation = function (bot, message, cb) {\n    botkit.startTask(bot, message, function (task, convo) {\n      cb(null, convo);\n    });\n  };\n\n  botkit.createConversation = function (bot, message, cb) {\n    var task = new Task(bot, message, this);\n    task.id = botkit.taskCount++;\n    var convo = task.createConversation(message);\n    this.tasks.push(task);\n    cb(null, convo);\n  };\n\n  botkit.defineBot = function (unit) {\n    if (typeof unit != 'function') {\n      throw new Error('Bot definition must be a constructor function');\n    }\n\n    this.worker = unit;\n  };\n\n  botkit.spawn = function (config, cb) {\n    var worker = new this.worker(this, config); // mutate the worker so that we can call middleware\n\n    worker.say = function (message, cb) {\n      var platform_message = {};\n      botkit.middleware.send.run(worker, message, function (err, worker, message) {\n        if (err) {\n          botkit.log('An error occurred in the send middleware:: ' + err);\n\n          if (cb) {\n            cb(err);\n          }\n        } else {\n          botkit.middleware.format.run(worker, message, platform_message, function (err, worker, message, platform_message) {\n            if (err) {\n              botkit.log('An error occurred in the format middleware: ' + err);\n\n              if (cb) {\n                cb(err);\n              }\n            } else {\n              worker.send(platform_message, cb);\n            }\n          });\n        }\n      });\n    }; // add platform independent convenience methods\n\n\n    worker.startConversation = function (message, cb) {\n      botkit.startConversation(worker, message, cb);\n    };\n\n    worker.createConversation = function (message, cb) {\n      botkit.createConversation(worker, message, cb);\n    };\n\n    botkit.middleware.spawn.run(worker, function (err, worker) {\n      if (err) {\n        botkit.log('Error in middleware.spawn.run: ' + err);\n      } else {\n        botkit.trigger('spawned', [worker]);\n\n        if (cb) {\n          cb(worker);\n        }\n      }\n    });\n    return worker;\n  };\n  /*\n   * change the speed of sending messages in a conversation\n   * defaults to 1500\n   */\n\n\n  botkit.setTickDelay = function (delay) {\n    botkit.tickDelay = delay;\n  };\n\n  botkit.startTicking = function () {\n    if (!botkit.tickInterval) {\n      // set up a once a second tick to process messages\n      botkit.tickInterval = setInterval(function () {\n        botkit.tick();\n      }, botkit.tickDelay);\n    }\n  };\n\n  botkit.shutdown = function () {\n    if (botkit.tickInterval) {\n      clearInterval(botkit.tickInterval);\n    }\n  };\n\n  botkit.startTask = function (bot, message, cb) {\n    var task = new Task(bot, message, this);\n    task.id = botkit.taskCount++;\n    botkit.debug('[Start] ', task.id, ' Task for ', message.user, 'in', message.channel);\n    var convo = task.startConversation(message);\n    this.tasks.push(task);\n\n    if (cb) {\n      cb(task, convo);\n    } else {\n      return task;\n    }\n  };\n\n  botkit.tick = function () {\n    for (var t = 0; t < botkit.tasks.length; t++) {\n      botkit.tasks[t].tick();\n    }\n\n    for (var t = botkit.tasks.length - 1; t >= 0; t--) {\n      if (!botkit.tasks[t].isActive()) {\n        botkit.tasks.splice(t, 1);\n      }\n    }\n\n    this.trigger('tick', []);\n  }; // Provide a fairly simple Express-based webserver\n\n\n  botkit.setupWebserver = function (port, cb) {\n    if (!port) {\n      throw new Error('Cannot start webserver without a port');\n    }\n\n    var static_dir = process.cwd() + '/public';\n    if (botkit.config && botkit.config.webserver && botkit.config.webserver.static_dir) static_dir = botkit.config.webserver.static_dir;\n    botkit.config.port = port;\n    botkit.webserver = express();\n    botkit.webserver.use(function (req, res, next) {\n      req.rawBody = '';\n      req.on('data', function (chunk) {\n        req.rawBody += chunk;\n      });\n      next();\n    });\n    botkit.webserver.use(bodyParser.json());\n    botkit.webserver.use(bodyParser.urlencoded({\n      extended: true\n    }));\n    botkit.webserver.use(express.static(static_dir));\n    botkit.webserver.listen(botkit.config.port, botkit.config.hostname, function () {\n      botkit.log('** Starting webserver on port ' + botkit.config.port);\n\n      if (cb) {\n        cb(null, botkit.webserver);\n      }\n\n      botkit.trigger('webserver_up', [botkit.webserver]);\n    });\n    return botkit;\n  };\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n  /**\n   * Define a default worker bot. This function should be customized outside\n   * of Botkit and passed in as a parameter by the developer\n   */\n\n\n  botkit.worker = function (botkit, config) {\n    this.botkit = botkit;\n    this.config = config;\n\n    this.say = function (message, cb) {\n      botkit.debug('SAY:', message);\n\n      if (cb) {\n        cb();\n      }\n    };\n\n    this.replyWithQuestion = function (message, question, cb) {\n      botkit.startConversation(message, function (convo) {\n        convo.ask(question, cb);\n      });\n    };\n\n    this.reply = function (src, resp) {\n      botkit.debug('REPLY:', resp);\n    };\n\n    this.findConversation = function (message, cb) {\n      botkit.debug('DEFAULT FIND CONVO');\n      cb(null);\n    };\n  };\n  /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n\n\n  botkit.userAgent = function () {\n    if (!botkit.my_user_agent) {\n      // set user agent to Botkit\n      var ua = 'Botkit/' + botkit.version(); // add OS info\n\n      ua = ua + ' ' + os.platform() + '/' + os.release(); // add Node info\n\n      ua = ua + ' ' + 'node/' + process.version.replace('v', '');\n      botkit.my_user_agent = ua;\n    }\n\n    return botkit.my_user_agent;\n  };\n\n  botkit.version = function () {\n    if (!botkit.my_version) {\n      botkit.my_version = PKG_VERSION;\n    }\n\n    return botkit.my_version;\n  };\n\n  botkit.config = configuration;\n  /**\n   * Default the application to listen to the 0.0.0.0, the default\n   * for node's http module. Developers can specify a hostname or IP\n   * address to override this.\n   */\n\n  if (!botkit.config.hostname) {\n    botkit.config.hostname = '0.0.0.0';\n  }\n\n  if (!configuration.logLevel) {\n    if (configuration.debug) {\n      configuration.logLevel = 'debug';\n    } else if (configuration.log === false) {\n      configuration.logLevel = 'error';\n    } else {\n      configuration.logLevel = 'info';\n    }\n  }\n\n  if (configuration.logger) {\n    if (typeof configuration.logger.log === 'function') {\n      botkit.logger = configuration.logger;\n    } else {\n      throw new Error('Logger object does not have a `log` method!');\n    }\n  } else {\n    botkit.logger = ConsoleLogger(console, configuration.logLevel);\n  }\n\n  botkit.log = function () {\n    botkit.log.info.apply(botkit.log, arguments);\n  };\n\n  Object.keys(LogLevels).forEach(function (level) {\n    botkit.log[level] = botkit.logger.log.bind(botkit.logger, level);\n  });\n  botkit.debug = botkit.log.debug;\n\n  if (!botkit.config.disable_startup_messages) {\n    // eslint-disable-next-line no-console\n    console.log('Initializing Botkit v' + botkit.version());\n  }\n\n  if (configuration.storage) {\n    if (configuration.storage.teams && configuration.storage.teams.get && configuration.storage.teams.save && configuration.storage.users && configuration.storage.users.get && configuration.storage.users.save && configuration.storage.channels && configuration.storage.channels.get && configuration.storage.channels.save) {\n      botkit.log('** Using custom storage system.');\n      botkit.storage = configuration.storage;\n    } else {\n      throw new Error('Storage object does not have all required methods!');\n    }\n  } else if (configuration.json_file_store) {\n    botkit.log('** Using simple storage. Saving data to ' + configuration.json_file_store);\n    botkit.storage = simple_storage({\n      path: configuration.json_file_store\n    });\n  } else {\n    botkit.log('** No persistent storage method specified! Data may be lost when process shuts down.');\n  } // set the default set of ears to use the regular expression matching\n\n\n  botkit.changeEars(botkit.hears_regexp); //enable Botkit Studio\n\n  studio(botkit);\n  return botkit;\n}\n\nmodule.exports = Botkit;","map":null,"metadata":{},"sourceType":"module"}